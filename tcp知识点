1、TCP序列号随机取值的原因：
  在TCP的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，
  黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。
2、TCP三次握手和四次挥手过程：
  详情点击：http://blog.csdn.net/guyuealian/article/details/52535294
3、Linux网络编程相关命令：
  netsat
    -a 显示所有选项，默认不显示listen相关的；
    -t 显示tcp相关的；
    -u 显示udp相关的；
    -n 拒绝显示别名，能显示数字的尽量显示数字；
    -l 仅仅列出正在listen的服务状态；
    -r 显示路由信息，路由表;
    -e 显示扩展信息，如uid;
    -s 按各个协议进行统计;
    -c 每隔一个固定时间，执行该netstat命令.
  tcpdump
    tcpdump i- eth1 监视指定网络接口的数据包,如果不指定网卡，默认会监视第一个网络接口，一般为eth0；
    tcpdump host dwade 监视所有进入或者离开dwade主机的数据包，dwade也可以是IP地址；
    tcpdump host dwade and \(james or bosh\) 监视所有dwade与james或者bosh通信的数据包；
    tcpdump host dwade and not james 监视所有dwade的通信包，但是不包括与james通信的数据包；
    tcpdump ip host 210.27.48.1 and not 210.27.48.2 监视所有201.27.48.1的通信IP数据包，但是不包括与201.27.48.1的通信ip数据包；
    tcpdump -i eth0 src host dwade 监视主机dwade发出的数据包；
    tcpdump -i eth0 dst host dwade 监视主机dwade收到的数据包。
    
  tcp序列号回绕与解决
    问题描述
    tcp协议头中有seq和ack_seq两个字段，分别代表序列号和确认号。tcp协议通过序列号标识发送的报文段。seq的类型是__u32，当超过__u32的最大值时，会回绕到0。
    一个tcp流的初始序列号（ISN）并不是从0开始的，而是采用一定的随机算法产生的，因此ISN可能很大（比如(2^32-10)），因此同一个tcp流的seq号可能会回绕到0。
    而我们tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。

    内核解决办法
    内核中给出的序列号(解决序列号回绕问题)判断解决方案十分简洁：
    /*
     * The next routines deal with comparing 32 bit unsigned ints
     * and worry about wraparound (automatic with unsigned arithmetic).
    */
    static inline int before(__u32 seq1, __u32 seq2)
    {
      return (__s32)(seq1-seq2) < 0;
    }
    #define after(seq2, seq1) before(seq1, seq2)

   原理
    为什么（__s32）(seq1-seq2)<0就可以判断seq1<seq2呢？这里的__s32是有符号整型的意思，而__u32则是无符号整型。< style="-ms-word-wrap: break-word;" div="">

    为了方便说明，我们以unsigned char和char为例来说明：
    假设seq1=255， seq2=1（发生了回绕）。
    seq1 = 1111 1111 seq2 = 0000 0001
    我们希望比较结果是seq1<seq2< style="-ms-word-wrap: break-word;" div="">

    seq1 - seq2=
    1111 1111
   -0000 0001
    -----------
    1111 1110

    由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为
    0000 0001 + 1 = 0000 0010 = 2

    因此seq1 - seq2 < 0

    注意：
    如果seq2=128的话，我们会发现：
    seq1 - seq2=
    1111 1111
   -1000 0000
    -----------
    0111 1111

    此时结果尤为正了，判断的结果是seq1>seq2。因此，上述算法正确的前提是，回绕后的增量小于2^(n-1)-1。

    由于tcp序列号用的32位无符号数，因此可以支持的回绕幅度是2^31-1，满足要求了。
